# Technical
LO4.11.2.5
Enterprise transformation
Assess existing legacy software, and review the source code if available, appreciating that part or all of the system may be implemented using an obsolete programming language.
Take a look in the https://archive.org/details/software.
Other things you can do is the master the mainframe - think COBOL, REXX - is there such a thing as an obsolete programming language?
What does actually mean do you think?
Make sure you provide justification through academic literature that looks at historic trends in languages and also think about the impact of legacy software in terms of security, usability, accessibility etc.


In software development, things are always evolving. I am 37 years old and I have observed the lifecycle of several programming languages. I never worked with COBOL or FORTRAN, but I knew that once they were pillars in business and scientific computing. Now, they are mostly used in old, outdated systems. Turbo Pascal, which was my first programming language, played a significant role in computer science education. Today, Python and Java are more dominant. Even Objective-C, which not long ago was used to make iPhone apps, has been largely replaced by Swift. It's important for professionals to keep track of new developments and regularly update their skills. Staying informed about the latest technological trends helps ensure one remains effective and valuable in this fast-changing field. New languages that work better, have more features, and are easier to use will always replace older ones. Looking at this trend, I can see that being able to adapt and learn new technologies is really important for developers today. (Meyerovich & Rabkin, 2013)

Before diving into enterprise-level legacy systems, I reflected on my own experience with ActionScript—used in Flash-based applications. While I never encountered COBOL or REXX, ActionScript shaped how I understand obsolete languages. Although no longer developed or maintained, ActionScript-based systems still exist, especially in older educational tools or multimedia websites. This made me realize that "obsolete" doesn’t mean “gone”—it means “no longer evolving,” and that’s a critical distinction when we assess legacy software in enterprise contexts. As Valverde and Solé (2015) explained, programming languages go through a kind of cultural evolution—they become popular when a strong developer community forms around them, but start to fade once that community loses interest or moves on.

Modern programming languages benefit from constant updates, community support, and security patches. For example, even a popular and actively maintained framework like Next.js recently faced a newly discovered vulnerability—despite being updated regularly (Hutton, 2025). This shows how hard it is to keep systems secure even when they're actively supported. Now I imagin the risk for a system written in COBOL or ActionScript—languages that haven’t been updated in years. Gerasimou et al. (2018) point out that unsupported software often carries unresolved bugs, which become easy entry points for attackers. In today’s AI-driven landscape, such systems become increasingly vulnerable and are easy targets for exploitation.

Beyond security, legacy software also struggles with usability and accessibility. Old-school systems often rely on outdated user interfaces that were never designed with modern usability principles in mind. I’ve seen this in some old web tools that don’t even respond well to screen readers or keyboard navigation. Tilley and Smith (2000) emphasize that modernizing the interface alone can significantly improve user productivity. But in many cases, the core system is so outdated that patching the UI doesn’t fix the deeper issues. Accessibility standards like WCAG didn’t exist when many of these tools were built, which makes them difficult or even impossible to use for people who rely on assistive technologies—like screen readers, voice control, or alternative input devices.

Understanding legacy systems and obsolete languages like ActionScript or COBOL is essential for modern software development. While these systems may still function, their lack of updates, limited community support, and increased security risks make them unsustainable long-term. As Meyerovich & Rabkin (2013) and Carnegie Mellon SEI (2000) highlight, success in programming often follows active ecosystems and maintainability. Modernization isn’t just about newer tech—it’s about choosing tools that evolve, that are secure, usable, and accessible to everyone. 

Carnegie Mellon SEI (2000) A Survey of Legacy System Modernization Approaches. CMU/SEI-2000-TN-003. Available at: https://resources.sei.cmu.edu/library/asset-view.cfm?assetid=5145 (Accessed: 01 April 2025).

Gerasimou, S., Kechagia, M., Kolovos, D. and Paige, R. (2018) ‘On software modernisation due to library obsolescence’, Proceedings of the 6th ACM SIGPLAN International Workshop on API Usage and Evolution, pp. 1–5. doi:10.1145/3194790.3194791.

Hutton, C. (2025) Notable vulnerabilities in Next.js (CVE-2025-29927) and CRUSHFTP: Rapid7 blog, Rapid7. Available at: https://www.rapid7.com/blog/post/2025/03/25/etr-notable-vulnerabilities-in-next-js-cve-2025-29927/ (Accessed: 01 April 2025).

Meyerovich, L.A. and Rabkin, A.S. (2013) ‘Empirical analysis of programming language adoption’, ACM SIGPLAN Notices, 48(10), pp. 1–18. doi:10.1145/2544173.2509515.

Migrator (2022) Top 10 outdated programming languages to forget in 2022, Analytics Insight. Available at: https://www.analyticsinsight.net/insights/top-10-outdated-programming-languages-to-forget-in-2022 (Accessed: 01 April 2025).

Oosterhof, N. (2023) Outdated and outmoded: The legacy of obsolete programming languages, net2. Available at: https://net2.com/obsolete-programming-languages/ (Accessed: 01 April 2025).

Valverde, S. and Solé, R.V. (2015) ‘Punctuated equilibrium in the large-scale evolution of programming languages’, Journal of the Royal Society Interface, 12(107), 20150249. doi:10.1098/rsif.2015.0249.

